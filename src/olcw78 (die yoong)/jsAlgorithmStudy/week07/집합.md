# 집합과 상호배타적 집합의 개념

## 집합의 개념

순서와 중복이 없는 원소들을 갖는 자료구조.
A={1, 6, 6, 6, 4, 3}는 집합으로
A'={1, 6, 4, 3} 이다. 순서는 상관 없으니 {6, 1, 3, 4}도 같음.

## 집합의 종류
### 상호배타적 집합이란?

교집합이 없는 집합 관계.

### 상호배타적 집합의 특성을 활용하는 분야

- 그래프 알고리즘에서 많이 쓰여서 그래유 -> 사이클 확인하는 일.
- 이미지 분할: 이미지를 서로 다른 부분으로 나누는 데 사용합니다. e.g. 사람 <-> 배경 분리
- 도로 네트워크: 도로 구축 시 각 도로가 교차하지 않도록 설계하는 데 사용.
- 최소 신장 트리 알고리즘 구현: 최소 신장 트리 알고리즘을 구현해서 간선을 추가할 때 마다 사이클을 형성하는지 여부 체크.
- 게임 개발: 플레이어, 적군이 충돌할 때 충돌하지 않도록?
- 클러스터링 작업: 각 작업이 서로 겹치지 않도록 구성.

## 집합의 연산

트리 로 표현. 대표연산은 합치기& 탐색.

### 배열을 활용한 트리로 집합 표현하기

배열활용 트리로 구현. 각 집합에는 대표 원소가 있어야 함.

### 대표 원소

집합의 원소 중 집합을 대표하는 역할. 트리로 표현 할 것이므로 대표 원소는 루트 노드.

### 배열로 집합을 표현하는 것이란?

하나의 배열로 상호배타적 관계를 갖는 집합을 모두 표현하는 것.
- 배열의 인덱스는 자신을, 배열값은 부모 노드를 의미.
e.g. disjointSet[3] = 9 // 노드 3의 부모 노드는 9임.
루트 노드는 부모 노드가 자기자신.

크기는 가장 큰 원소 + 1 (배열이 0부터 시작)

### 집합 표현 정리

서로 다른 집합 A, B 가 있을 때, 둘다 1개의 배열에 표현이 가능.

1. 초기 노드는 자기자신을 루트노드로 둠
2. 값에 없는 인덱스의 값은 -1
3. 1, 2, 3, 4, 5, 8, 9 는 연결되어 있지 않아 자기 자신을 부모 노드로 함.

## 유니온-파인드 알고리즘

주로 쓰이는 연산은 합치기 & 탐색.
합치기 -> union
탐색 -> find

### 파인드 연산

특정 노드의 루트 노드가 무엇인지 탐색하는 방법. 보통은 특정 노드가 같은 집합에 있는지 확인할 때 사용.
e.g. 노드 A, B 의 루트 노드가 같으면 같은 집합에 속한 것.

1. 현재 노드의 부모 노드를 확인. 부모 노드를 확인하다가 부모 노드가 루트 노드이면 파인드 연산 종료.
2. 1이 종료되지 않으면 1을 반복.

01. find(7) <- 노드 7의 루트 노드를 찾는 과정.
02. disjointSet[7] == 6
03. if 6 != disjointSet[7] -> 현재 노드를 부모 노드인 6 으로 변경. 02. 반복
04. disjointSet[6] == 2
05. if 2 != disjointSet[6] -> 현재 노드를 부모 노드인 2 으로 변경. 02. 반복
06. disjointSet[2] == 1
07. if 1 == disjointSet[2] -> 찾았다 find 연산 종료.

TC 가 최악의 경우 O(N) 이라서 최적화 필요.

### 파인드 연산 비용 -> 경로 압축.

집합 형태를 유지하면서도 트리 높이를 줄이면 됨.

## 유니온 연산

두 집합을 하나로 합치는 연산. -> 두 집합의 루트 노드를 같게 하는 것. 두 집합의 루트 노드 중 하나가 되면 됨.

1. 두 집합에서 파인드 연산으로 루트 노드들을 찾음.
2. 찾은 두 루트 노드의 값을 비교.
3. 두 집합을 합친다. 두 집합의 루트 노드를 같게함. 어떤 루트를 골라도 상관 없음.

### 유니온온 연산 비용 문제 -> 랭크

트리의 깊이가 깊어질수록 연산 비용이 커짐.

랭크 -> 현재 노드 기준 가장 깊은 노드까지의 경로길이.
랭크 기반으로 유니온 연산
랭크값이 큰 루트 노드를 기준으로 삼아
랭크가 더 큰 루트 노드를 작은 루트 노드의 부모 노드로 바꿈.




