# 해시 함수

기본적으로 js 에서는 object, map 을 해시구현체로 제공함.

## 구현시 고려할 내용

1. 해시값은 인덱스로 활용되어야 하므로 해시 테이블의 크기를 넘을 수 없다.
2. 해시값의 충돌은 최소화하자. (서로 다른 두 키에 대해 해싱 함수를 적용한 결과가 동일한 것)

## 해시함수 

### 나눗셈범

키를 소수로 나눈 나머지를 사용.
hash(x) = x mod k, where x is key, k is prime number
소수를 사용하는 이유는, 소수가 아닌 수를 mod 할때 약수가 많아 일정 주기로 결과가 반복될 수 있기 때문.

- 나눗셈법의 해시 테이블의 크기는 k
0 ~ (k-1) 의 주기로 값이 반복되므로. 한계가 있음.
크기를 늘리기 위해서는 더 많은 소수를 계산해야하는 데, 계산 자체가 오래걸려서 기계적으로 해야할 수가 있음. 

### 곱셈법

모듈러 연산을 활용하지만 소수는 X

hash(x) = (((x * A) mod 1) * m)
where m is maximum number of bucket, A is golden ratio number which is about 1.6180339887.
1. 키에 황금비를 곱한다.
2. 1. 에 mod 1 -> 정수부를 버리고 소수부만 취함.
3. 2. 에 테이블의 크기 m 을 곱하여 해시 테이블에 맵핑가능.

소수부와는 다르게 테이블의 크기 증가에 추가 작업이 없다.

### 문자열 해싱

나눗셈법, 곱셈법은 키의 자료형이 숫자.
문자열 해싱은 키의 자료형이 문자열일때 사용.

문자열의 문자를 숫자로 변환하고 이 숫자들을 다항식의 값으로 변환해서 해싱.

[polynominal rolling method]
hash(s) = (s[0] * p^0 + s[1] * p^1 + s[2] * p^2 + ... + s[n-1] * p^(n-1)) mod m

where
p = 31, (31 is a prime number and a mersenne prime number)
m = maximum size of a hashtable

a b c d e ... z
1 2 3 4 5 ... 26

apple
1 16 16 12 5
1*1 + 16 * 31 + 16 * 31^2 + 12 * 31^3 + 5 * 31^4 = 

4990970 -> 값이 너무커서 오버플로우 발생 가능 ->
4990970 % 5 = 0

(a + b) % c = (a % c + b % c) % c

hash(s) = (s[0] * p^0 % m + s[1] * p^1 % m + s[2] * p^2 % m + ... + s[n-1] * p^(n-1) % m) % m

1*1 % 5 + 16 * 31 % 5 + 16 * 31^2 % 5 + 12 * 31^3 % 5 + 5 * 31^4 % 5 = 5
5 % 5 = 0
