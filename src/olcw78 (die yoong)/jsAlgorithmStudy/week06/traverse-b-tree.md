# 이진 트리 탐색하기
바로 탐색을 효율적으로 할 수 있도록 트리를 구축하는 것.

## 이진 탐색 트리 구축하기
주어진 데이터가 3 -> 4 -> 2 -> 8 -> 9 -> 7 -> 1
데이터 크기를 따져 현재 노드보다 값이 작으면 왼쪽 자식 위치, 크거나 같으면 오른쪽 자식 위치에 배치.

## 이진 탐색 트리 탐색하기
1. 찾으려는 값이 현재 노드의 값과 같으면 탐색을 종료하고 크면 오른쪽 노드를 탐색.
2. 본인이 찾으려는 값이 현재 노드의 값보다 작으면 왼쪽 노드를 탐색.
3. 값을 찾으면 종료. 노드가 없을 때까지 계속 탐색했는데 값이 없으면 현재 트리에 값이 없는 것.

# 모든 탐색 알고르즘에서 탐색 효율을 개선하는 방법은 같다. -> 탐색 대상이 아닌 노드를 한 번에 많이 제외.
BTree 는 데이터 크기에 따라 하위 데이터 중 한 방향을 검색 대상에서 제외하므로 검색이 빠르다.

## 이진 탐색 트리의 시간 복잡도
시간 복잡도 는 트리의 균형에 의존.
트리의 균형이 잡힘 -> 각 노드의 차수가 비슷하게 유지. 각 노드의 자식 노드 수가 비슷하게 유지되는 것.
균형이 유지되었을 때 삽입, 탐색 시 B트리에 저장된 노드가 N개 일 때 시간 복잡도 -> O(logN).
하지만 균형이 맞지 않을 때는 시간 복잡도가 배열과 비슷.

## 이진 탐색 트리와 배열 탐색의 효율 비교
균형이 맞지 않으면 최악의 경우 O(N)으로 같다.

### 치우쳐진 형태의 트리
극단적으로 치우쳐진 형태의 트리 -> Degenerate BTree

#### 균형 이진 탐색 트리
이를 막기 위해 균형 이진탐색트리 (balanced binary search tree) 로 만든다.
AVL Tree, Red-Black Tree

탐색 연산 횟수가 트리 높이에 비례, 트리 높이는 logN이므로 탐색 시간 복잡도를 항상 O(logN)으로 유지할 수 있다.


