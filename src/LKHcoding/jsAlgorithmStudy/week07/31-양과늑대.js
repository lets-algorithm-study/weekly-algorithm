// https://school.programmers.co.kr/learn/courses/30/lessons/92343

// info = [0,0,1,1,1,0,1,0,1,0,1,1]
// 각 숫자는 해당 위치(인덱스)에 있는 동물을 나타냅니다
// 0은 양, 1은 늑대

// edges = [[0,1],[1,2],[1,4],[0,8]...]
// 각 배열은 [부모노드, 자식노드]를 나타냅니다

// info[0] = 0 은 0번 위치에 양이 있다는 뜻
// info[1] = 0 은 1번 위치에 양이 있다는 뜻
// info[2] = 1 은 2번 위치에 늑대가 있다는 뜻

// edges[0] = [0,1] 은 0번 노드가 1번 노드의 부모라는 뜻
// edges[1] = [1,2] 는 1번 노드가 2번 노드의 부모라는 뜻

// 아주 작은 트리를 만들어봅시다
const smallInfo = [0, 0, 1]; // 3개의 노드만 있는 트리
const smallEdges = [
  [0, 1],
  [0, 2],
]; // 0이 부모고, 1,2가 자식들

// 이것은 이런 모양입니다
//      0(양)
//     / \
//   1(양) 2(늑대)

// 이 경우 가능한 경로는:
// 1. 0 -> 1 : 양 2마리 모을 수 있음
// 2. 0 -> 2 -> 1 : 불가능 (늑대가 양을 잡아먹음)
// 3. 0 -> 1 -> 2 : 양 2마리, 늑대 1마리로 끝남
function solution(info, edges) {
  // 1. 먼저 트리 구조를 만듭니다
  const tree = {};

  // 각 노드의 자식들을 저장할 구조를 만듭니다
  for (const [parent, child] of edges) {
    if (!tree[parent]) {
      tree[parent] = [];
    }
    tree[parent].push(child);
  }

  let maxSheep = 0; // 최대로 모을 수 있는 양의 수

  // DFS 실행
  // 현재 위치, 현재 양의 수, 현재 늑대의 수, 갈 수 있는 다음 노드들
  function move(currentNode, sheep, wolf, nextPossible) {
    // 현재 노드의 동물 확인
    if (info[currentNode] === 0) {
      sheep += 1; // 양이면 양의 수 증가
    } else {
      wolf += 1; // 늑대면 늑대의 수 증가
    }

    // 늑대가 양보다 많으면 불가능
    if (wolf >= sheep) return;

    // 현재까지의 양의 수가 최대값보다 크면 갱신
    maxSheep = Math.max(maxSheep, sheep);

    // 다음에 갈 수 있는 노드들 계산
    const possibleNodes = [...nextPossible]; // 기존에 갈 수 있던 노드들

    // 현재 노드의 자식들 추가
    if (tree[currentNode]) {
      possibleNodes.push(...tree[currentNode]);
    }

    // 현재 노드는 제거 (이미 방문했으므로)
    const index = possibleNodes.indexOf(currentNode);
    if (index > -1) {
      possibleNodes.splice(index, 1);
    }

    // 가능한 모든 다음 노드로 이동해보기
    for (const nextNode of possibleNodes) {
      move(nextNode, sheep, wolf, possibleNodes);
    }
  }

  // 0번 노드(루트)에서 시작
  move(0, 0, 0, [0]);

  return maxSheep;
}

console.log(
  solution(
    [0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
    [
      [0, 1],
      [1, 2],
      [1, 4],
      [0, 8],
      [8, 7],
      [9, 10],
      [9, 11],
      [4, 3],
      [6, 5],
      [4, 6],
      [8, 9],
    ]
  )
);

/**
 * 이 문제는 사람이 이해하기 로는 방문했던 노드로 되돌아가서
 * 다음 방문 가능한 노드들을 탐색해 나가야 하나 싶었는데
 * 그럴 필요가 없었다.
 * 그냥 루트에서 부터 모든 노드 탐색해가면서 최대 양 수를 구하면 되는 개념이다.
 * 탐색 과정 자체가 닥터스트레인지가 시간 되돌리듯이
 * 재귀 내에 return 부분과 for 문 재귀 실행 부분을 보면
 * 문제가 없던 부분으로 되돌아가서 모든 노드를 탐색한다.
 */

// ------------------------------------------------

/**
 * 문제 풀이 전략 수립을 위해 어떻게 사고 해야 할까?
 *
 * 1. **문제 분석**
 *    - 트리를 돌아다니면서 양을 최대한 많이 모아야 함
 *    - 늑대가 양보다 같거나 많아지면 실패
 *    - 어떤 순서로 방문하느냐에 따라 결과가 달라짐
 *    - 한 번 방문한 노드는 다시 방문할 필요 없음
 *
 * 2. **핵심 특징 파악**
 *    - "모든 가능한 경로를 탐색해야 한다" -> DFS/BFS 같은 탐색 알고리즘 필요성 인식
 *    - "매 순간 늑대/양의 수를 체크해야 한다" -> 상태를 추적해야 함
 *    - "최대값을 찾아야 한다" -> 모든 경우를 다 살펴봐야 함
 *
 * 3. **해결 전략 수립**
 *    ```
 *    "이 문제는 결국..."
 *    - 매 노드에서 '갈 수 있는 모든 선택지'를 시도해봐야 함
 *    - 각 선택에서 양/늑대 수를 체크해야 함
 *    - 가능한 모든 경로를 탐색해야 함
 *    ```
 *
 * 4. **알고리즘 선택**
 *    - DFS가 적합한 이유:
 *      - 한 경로를 끝까지 탐색하고
 *      - 다시 돌아와서 다른 경로를 시도할 수 있음
 *      - 상태(양/늑대 수)를 유지하기 쉬움
 *
 * 5. **구현 방향 결정**
 *    ```
 *    필요한 것들:
 *    1. 트리 구조 표현
 *    2. 현재 상태 추적 (양/늑대 수)
 *    3. 다음에 갈 수 있는 노드들 관리
 *    4. 최대값 갱신 로직
 *    ```
 *
 * 실제로 이런 사고 과정을 거치려면 다음과 같은 연습이 도움됩니다:
 *
 * 1. 작은 예시로 시작하기
 *    - 노드 2-3개로 시작해서 패턴 파악
 *    - 직접 손으로 그려가며 경우의 수 나열
 *
 * 2. 극단적인 경우 생각하기
 *    - 모든 노드가 양인 경우
 *    - 늑대가 많은 경우
 *    - 경로가 한 줄로 이어진 경우
 *
 * 3. 패턴 인식하기
 *    - "이전에 비슷한 문제를 풀어봤나?"
 *    - "이런 유형은 보통 어떤 알고리즘을 쓸까?"
 *    - "상태를 어떻게 추적해야 할까?"
 *
 * 4. 문제 단순화하기
 *    - 처음에는 제약조건 일부를 무시
 *    - 점진적으로 조건을 추가하며 해결
 *
 * 이런 접근 방식을 연습하면서 문제 해결 능력을 키울 수 있습니다.
 */
