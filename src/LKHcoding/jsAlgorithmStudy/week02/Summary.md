## 실패율
1. 스테이지별 도전자 수를 구하는것부터 쉽게 떠오르지 않았었음
2. 문제부터 제대로 이해하고, 어떻게 풀지 종이에 쓰거나, 주석으로 써서 이해한 다음 푸는게 좋다는 생각이 듬
3. 데이터 순회용 인덱스(커서)를 1부터 쓰기위해 첫번째 값을 무시하는 방법도 있다고 알려줌 (편리)

## 방문길이
1. 이문제 처음 봤을때 set을 쓸 생각은 안들었고, object 만들어서 key가 있는지 체크하려고 했는데,  
그냥 set쓰는게 더 편함.
2. 가봤던 길인지 체크하는 문제라, 방향 정보가 없어서,  
set에 양방향으로 추가해주고 2로 나누면 되는지 생각 못했음  
한번 이동시마다 반대방향도 간적 있었는지 체크하려고 생각했는데 더 복잡했을듯.

## Stack의 정의, ADT
스택이 뭔지는 당연히 알지만 ADT는 처음 들어봄
> ADT?  
> 추상 자료형 (abstract data type)  
> 자료형의 설계도

연산
- push
- pop
- isFull
- isEmpty

상태
- top
- maxsize

js는 딱히 stack을 직접 구현할 필요는 없고 array 내장메소드 쓰면 됨

## 괄호 회전하기
문제를 보고 실제로 괄호들을 한칸씩 밀어서 체크하려고 했는데, 이렇게 하면  
연산 비용이 많이 든다.  
for문을 돌릴때
```typescript
const s = '()()';
const n = s.length;

for (var i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    const char = s[(i + j) % n];
  }
}
```
이렇게 % n 로 다시 처음부터 커서가 돌아가게 해서 굳이 실제 배열을 쉬프트 하지 않고  
할 수 있는 방법을 알려줌

약간의 분기쳐야하는 컨텍스트 집중력이 필요했다.
