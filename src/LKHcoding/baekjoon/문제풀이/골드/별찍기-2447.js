const fs = require('fs');
const filePath = process.platform === 'linux' ? '/dev/stdin' : './input.txt';
const input = +fs.readFileSync(filePath).toString().trim();

solution(input);

function solution(n) {
  let answer = '';
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < n; ++j) {
      answer += makeStar(i, j, n);
    }
    answer += '\n';
  }

  console.log(answer);
}

function makeStar(x, y, num) {
  // 'i % 3 === 1 && j % 3 === 1' 조건은 주어진 좌표가 별 모양의 '중앙'에 위치해야 할지를 확인합니다.
  // 3x3의 별 패턴에서 중앙에 위치한 하나의 칸은 공백이 되어야 하기 때문입니다.
  // 이런 패턴은 더 큰 사이즈의 별에서도 계속해서 유지됩니다. 즉, 크기가 커질수록 더 많은 공백이 있는 구역이 생깁니다.
  // 따라서 i와 j가 모두 3으로 나누어 떨어질 경우, 해당 좌표는 공백이 되어야 하는 중앙 위치에 있다고 판단하고 공백을 반환합니다.
  if (x % 3 === 1 && y % 3 === 1) {
    return ' ';
  }
  if (num !== 1) {
    // 만약 num 이 1보다 크다면, 별의 크기를 줄이기 위해 num 을 3으로 나눕니다.
    // 이 과정에서 별 모양은 더 작은 3x3 크기의 별로 나뉘게 됩니다.
    // 이런 식으로 재귀 호출을 계속하면, 별 모양을 그리는 작업은 점점 더 작은 별로 나뉘게 되어 복잡한 패턴을 만들게 됩니다.
    // 이때 i와 j를 각각 3으로 나눈 몫을 재귀 호출에 전달함으로써, 좌표를 현재 별의 크기에 맞게 조정하게 됩니다.
    return makeStar(Math.trunc(x / 3), Math.trunc(y / 3), num / 3);
  }

  // num 이 1이라는 것은 별 모양의 가장 작은 단위, 즉 3x3 크기의 별에서 가장 작은 1x1 크기의 별을 그리는 경우를 의미합니다.
  // 이 경우 별(*)을 그립니다.
  return '*';
}

/**
 * NOTE: 이문제를 혼자서 바로 풀지 못했다 (23.06.07)
 *  아직 재귀가 약한듯하다.
 *  24번라인의 mode 3이 1일때 라는 개념을 제대로 이해하기 힘들었다.
 *  (계속 x,y를 3으로 나눠가면서 재귀를 돌게되는데
 *  소수점 버리고 결국 1이 된다는건 큰 그림에서 봤을때도 1,1 위치니까 가운데라는 뜻이다.)
 *  문제를 봤을때 전략을 세우는 법이 아직 약한것같다.
 *  패턴이 보이는 문제면 재귀를 떠올리고, 기본 단위를 어떻게 잡을지 생각해보자.
 *  프랙탈 구조라면 분할 정복 ( 작은 문제를 해결하면 큰 문제가 저절로 해결됨 ) 관점을 떠올려보자.
 */

/**
 * NOTE: 분할 정복 방법론
 *  "분할 정복"이란 큰 문제를 작은 문제로 나눠서 풀어나가는 알고리즘 설계 전략입니다.
 *  이 접근법은 큰 문제를 더 작은 하위 문제들로 분할하고,
 *  이 작은 문제들을 개별적으로 해결한 후,
 *  그 결과들을 결합하여 원래의 문제를 해결합니다.
 *  "문제를 더 작은 문제로 나눈다"는 것은 큰 문제를 동일한 유형의 더 작은 문제들로 분할하는 것을 의미합니다.
 *  이 경우, 작은 문제는 원래 문제보다 더 쉽게 해결할 수 있으며,
 *  이 작은 문제들의 해결책을 결합함으로써 원래의 큰 문제를 해결합니다.
 *  이 문제에 적용해보면, 전체 별 찍기 패턴(큰 문제)을 3x3 그리드의 별 찍기 패턴(작은 문제)으로 나누는 것이 분할하는 과정입니다.
 *  작은 3x3 그리드에서 각 위치에 별을 찍을지 공백을 둘지 결정하고,
 *  이를 결합하여 전체 별 찍기 패턴을 만드는 것이 정복하는 과정입니다.
 *  이 작은 문제를 해결하는 과정이 재귀적으로 반복되면서, 전체 문제를 해결하게 됩니다.
 */
