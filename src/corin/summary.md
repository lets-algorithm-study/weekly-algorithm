# 그래프

## 그래프의 개념

- 그래프는 노드(데이터)와 간선(관계나 흐름)을 이용한 비선형 데이터 구조.
- 데이터 간의 관계 표현 하는 데 사용.
- 가중치 : 관계나 흐름에서 정도를 표현하기 위한 장치

### 그래프 용어 정리

- 동그라미 : 노드(데이터)
- 화살표 : 간선
- 간선 위의 숫자 : 가중치

### 그래프의 특징과 종류

그래프는 방향성, 가중치, 순환 특성에 따라 종류를 구분할 수 있음

#### 방향성 : 흐름을 표현

간선을 방향을 가질 수도(방향 그래프) 있고 없을 수 도(무방향 그래프, 비방향 그래프) 있음. 
서로 반대를 가리킬 수 도 있음

#### 가중치 : 흐름의 정도를 표현

어떤 데이터는 흐름의 방향 뿐만아니라 양도 중요할 수 있음. 가중치 그래프라고 함.


#### 시작과 끝의 연결 여부를 보는 순환

특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있음. 순환이 존재 하는 것(순환 그래프)과 존재하지 않는 것(비숫환 그래프)가 있음


### 그래프 구현

#### 인접행렬 그래프 표현

![alt text](image-8.png)

2차원 배열 활용하여 구현하는 경우가 많음.
- 노드 : 배열의 인덱스
- 노드의 가중치 : 배열 값
- 출발 노드 : 인덱스 세로방향
- 도착 노드 : 인덱스 가로방향

#### 인접 리스트 그래프 표현

값=정점(v), 가중치(w), 다음 노드(next)를 묶어 관리

![alt text](image-7.png)

  1. 노드 개수만큼 배열 준비
  2. 배열의 인덱스는 각 시작 노드를 의미하며 배열의 값에는 다음 노드를 연결

#### # 인접 행렬과 인접 리스트의 장단점

**인접 행렬의 장단점**
-  단점
   -  인접 행렬로 희소 그래프를 표현할 때
      -  희소 그래프 : 노드 수에 비해 간선 수가 매우 적은 그래프
      -  인접 행렬은 크기가 고정되어 있으므로 최악의 경우를 고려해서 크기를 결정해야함. 즉, 최악의 경우를 고려하여 N x N 크기의 인접 행렬 필요. O(N^2)_
   - 노드들의 값 차이가 매우 큰 그래프 표현하는 경우
     - 예 : 1,2,3,999 와 같이 노드값이 증가한다면 999를 기준으로 인접 행렬 크기 잡아야 함.
 - 장점
   - 간선의 정보를 확인할 때의 시간복잡도가 O(1)
     - 인덱스 임의 접근으로 노드 간 간선 정보를 바로 확인 가능
     - 예 : 2에서 93이 연결되어 있는지 탐색하려면 array[2][93]에 가중치가 있는지만 확인하면 됨. 
     - 구현난이도가 낮음

**인접 리스트의 장단점**
- 인접 행렬과 정반대.
- 메모리 사용 : O( N + M )
- 시간 복잡도 : O(M)
  - M은 간선의 개수

** 문제에서 노드 개수가 1,000개 미만으로 주어지는 경우에는 인접 행렬 사용하면 됨
** 노드의 데이터가 숫자가 아닌 문자열이면, 문자열을 숫자로 매핑하여 인접 행렬의 인덱스로 사용하면 됨.


## 그래프 탐색
그래프에서의 경로 탐색 방법 2가지
- 깊이 우선 탐색 (DFS) : 더 이상 탐색할 노드가 없을 때 까지 탐색 후, 최근에 방문했던 노드로 되돌아간 다음 가지 않은 노드를 방문
- 너비 우선 탐색 : 현재 위치에서 가장 가까운 노드부터 모두 방문 후 다음 노드로 넘어감. 그 노드에서 또 다시 가장 가까운 노드부터 모두 방문함.

### 깊이 우선 탐색

**진행순서**
 1. 먼저 시작 노드를 정한 후 스택에 시작 노드를 푸시한다. 스택에 있는 노드는 아직 방문하지 않았지만 방문할 예정인 노드임. 
 2. 스택이 비었는지 확인. 스택이 비었다는 것은 방문할 수 있는 모든 노드를 방문했음을 의미. 따라서 스택이 비었으면 탐색을 종료
 3. 스택에서 노드를 팝. 팝한 원소는 최근에 스택에 푸시한 노드
 4. 팝한 노드의 방문 여부 확인. 이미 방문했다면 별도의 처리 없음. 아직 방문하지 않았다면 노드를 방문 처리.
 5. 방문한 노드와 인접한 모든 노드를 확인. 그리고 그 중에서 아직 방문하지 않은 노드를 스택에 푸시. 스택은 LIFO 구조이므로 방문 순서를 오름차순으로 고려한다면 역순으로 노드 푸시해야함.

**고려사항**
- 탐색할 노드가 없을 때 까지 간선을 타고 내려갈 수 있어야함
- 가장 최근에 방문한 노드를 알아야 함
- 이미 방문한 노드인지 확인할 수 있어야 함

** 핵심 : 가장 깊은 노드까지 방문한 후에 더 이상 방문할 노드가 없으면 최근 방문한 노드로 돌아온 다음, 해당 노드에서 방문할 노드가 있는지 확인한다.

** 백트랙킹 : 최근 방문한 정점으로 거슬러 올라가는것. 즉, 탐색하고 있는 방향의 역방향으로 되돌아가는 동작. 스택으로 쉽게 구현 가능. 스택은 최근에 푸시한 노드를 팝할 수 있으므로 특정 노드를 방문하기 전에 최근 방문 노드를 팝 연산으로 쉽게 확인할 수 있음.

#### 스택을 활용한 깊이 우선 탐색
1. ![alt text](image.png)
2. ![alt text](image-1.png)
3. ![alt text](image-2.png)
4. ![alt text](image-3.png)
5. ![alt text](image-4.png)
6. ![alt text](image-5.png)
7. ![alt text](image-6.png)


#### 재귀 함수를 활용한 깊이 우선 탐색
스택을 사용하지 않고 깊이 우선 탐색 구현하는 방법. 재귀 함수를 호출할 때마다 호출한 함수는 콜 스택이라는 곳에 쌓이므로 깊이 우선탐색에 활용 가능.
- 예시
  - dfs() : 호출할 함수
  - dfs(N) : N번 노드를 방문 처리하고 N번 노드와 인접한 노드 중 아직 방문하지 않은 노드를 탐색
  


### 너비 우선 탐색 (BFS)

시작노드와 목표 노드까지의 차수가 가장 작은 즉, 시작노드와 거리가 가까운 노드를 우선하여 방문하는 방식의 알고리즘 (가중치의 합과 별개임). 큐(FIFO)를 활용하여 구현 가능. 

**진행 순서**
1. 큐가 비었는지 확인. 큐가 비었다면 방문할 수 있는 모든 노드 방문했다는 의미(탐색 종료).
2. 큐에서 노드 팝.
3. 팝한 노드와 인접한 모드 노드확인 후, 그 중 아직 방문하지 않은 노드를 큐에 푸시하며 방문처리함.

**고려 사항**
1. 현재 방문한 노드와 직접 연결된 모든 노드를 방문할 수 있어야 함.
2. 이미 방문한 노드인지 확인할 수 있어야함.

#### 큐를 활용한 너비 우선 탐색

FIFO 방식임. 간선 연결된 노드 전부 푸시하고, 먼저 푸시된 노드를 팝해서 방문안된 노드면 방문처리하면 됨

### 깊이 우선 탐색과 너비 우선 탐색 비교

#### 깊이 우선 탐색 : 깊이 탐색한 다음 되돌아옴

백트래킹의 특성이 있어서, 모든 가능한 해를 찾는 백트래킹 알고리즘을 구현할 떄나 그래프의 사이클을 감지해야 하는 경우 활용 가능. 코테에서는 탐색이나 최단경로 찾는 문제가 아니면 깊이 우선 탐색을 고려해보는 것이 좋음

#### 너비 우선 탐색 : 최단 경로를 보장
문제에 대한 답이 많은 경우 너비 우선 탐색은 이 답 중에서도 가장 가까운 답을 찾을 때 유요함. 미로 찾기 문제에서 최단 경로를 찾거나, 네트워크 분석 문제 풀 떄 활용 가능

** DFS, BFS 방문처리 시점 다른 이유

탐색 방식이 다르기 때문

- DFS : 스택에서 팝하며 방문처리
  - 방문 예정인 노드를 스택에 푸시함. 팝하며 방문처리를 해야함
- BFS : 큐에 푸시하며 방문처리
  - 지금 방문할 노드를 큐에 푸시함.

## 그래프 최단 경로 구하기

최단 경로는 그래프의 종류에 따라 진의를 잘 파악해야함.

- 가중치가 없는 그래프 : 간선개수가 가장 적은 경로가 최단 경오
- 가중치가 있는 그래프 : 일반적으로 시작 노드에서 끝 노드까지 이동할 때 거치는 간선의 가중치의 총합이 최소가 되는 것을 말함.

### 다익스트라 알고리즘 (어려움...)

가중치가 있는 그래프의 최단 경로를 구하는 문제는 대부분 다익스트라 알고리즘 사용함.

1. 시작 노드 설정 후 시작 노드부터 특정 노드까지의 최소 비용을 저장할 공간 과 직전 노드를 저장할 공간 마련
   1. 최소 비용을 저장할 공간은 모드 매우 큰 값으로 초기화
   2. **시작 노드의 최소비용은 0, 시작 노드의 직전 노드는 자신으로 함**
2. 방문 가능한 노드 중 현재까지 구한 최소 비용이 가장 적은 노드 구함.
   1. 해당 노드를 거쳐서 각 노드까지 가는 최소 비용과 현재까지 구한 최소 비용을 비교하여 작은 값을 각 노드의 최소 비용으로 갱신
   2. 이 때, 최소 비용이 갱신된 노드의 직전 노드도 같이 갱신
3. 노드 개수에서 1을 뺀 만큼 반복

** 다익스트라는 그리디적(매 순간마다 최선의 선택을 하는 것)으로 동작하기 때문에, 음의 가중치가 있으면 다익스트라 알고리즘이 항상 정확한 최단 경로를 보장할 수는 없음. 그러나 음의 가중치가 없다고 확신할 수 있다면 다익스트라 알고리즘은 더 좋은 성능을 나타냄.

### 벨만-포드 알고리즘

매 단계마다 모든 간선의 가중치를 다시 확인하여 최소 비용을 갱신하므로 음의 가중치를 가지는 그래프에서도 최단 경로 구할 수 있음. 다익스트라와 마찬가지로 노드에서 노드까지의 최소 비용을 구한다는 점은 동일.

1. 시작 노드를 설정한 다음 시작노드의 최소 비용은 0, 나머지 노드는 INF로 초기화. 이후 최소 비용을 갱신할 때 직전 노드도 갱신함 (다익스트라와 동일)
2. 노드 개수 -1만큼 다음 연산 반복.
   1. 시작 노드에서 갈 수 있는 각 노드에 대하여 전체 노드 각각을 거쳐갈 때 현재까지 구한 최소 비용보다 더 적은 최소 비용이 있는지 확인하여 갱신. 최소 비용을 갱신할 때, V의 직전 노드 값도 같이 갱신.
3. 과정 2-1 을 마지막으로 한 번 더 수행하여 갱신되는 최소 비용이 있는지 확인. 만약 있다면 음의 순환이 있음을 의미.

이해 안댐 모다겟음 422P
